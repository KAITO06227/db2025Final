<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ãƒšãƒ³ã‚®ãƒ³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ†æ</title>
    <style>
        body {
            font-family: 'Hiragino Kaku Gothic Pro', 'ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro W3', 'Meiryo', sans-serif;
            margin: 20px;
            background-color: #f0f8ff;
            color: #2c3e50;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 0 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .analysis-section {
            background-color: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-left: 5px solid #3498db;
        }
        
        .analysis-section h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .analysis-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .penguin-rank {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .penguin-rank h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        
        .rank-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background-color: white;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        
        .rank-item .rank-number {
            font-weight: bold;
            color: #e74c3c;
            margin-right: 10px;
            width: 25px;
        }
        
        .rank-item .penguin-name {
            font-weight: bold;
            color: #2c3e50;
            margin-right: 10px;
        }
        
        .rank-item .score {
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #7f8c8d;
            font-size: 18px;
        }
        
        .error {
            text-align: center;
            padding: 50px;
            color: #e74c3c;
            font-size: 18px;
        }
        
        .back-button {
            background-color: #95a5a6;
            margin-bottom: 20px;
        }
        
        .back-button:hover {
            background-color: #7f8c8d;
        }
        
        .analysis-description {
            background-color: #ebf3fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
        }
        
        .analysis-description h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        
        .analysis-description p {
            margin: 5px 0;
            line-height: 1.6;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
            margin: 10px 0;
        }
        
        .gender-male {
            color: #3498db;
        }
        
        .gender-female {
            color: #e91e63;
        }
    </style>
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="osql.js"></script>
</head>
<body>
    <h1>ğŸ§ ãƒšãƒ³ã‚®ãƒ³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ†æ ğŸ§</h1>
    
    <div class="controls">
        <button class="back-button" onclick="goBack()">â† ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å›³ã«æˆ»ã‚‹</button>
        <button onclick="loadAnalysis()">åˆ†æã‚’å®Ÿè¡Œ</button>
    </div>
    
    <div class="loading" id="loading" style="display: none;">
        åˆ†æã‚’å®Ÿè¡Œä¸­...
    </div>
    
    <div class="error" id="error" style="display: none;">
        åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ¥ç¶šã§ãã¾ã›ã‚“ã€‚
    </div>
    
    <div id="analysis-results" style="display: none;">
        
        <div class="analysis-section">
            <h2>ğŸ“Š æ¬¡æ•°ä¸­å¿ƒæ€§åˆ†æ</h2>
            <div class="analysis-description">
                <h3>æ¬¡æ•°ä¸­å¿ƒæ€§ã¨ã¯ï¼Ÿ</h3>
                <p>ç›´æ¥çš„ãªé–¢ä¿‚ã®æ•°ã‚’è¡¨ã™æŒ‡æ¨™ã§ã™ã€‚å‹é”ã‚„å®¶æ—ãªã©ã€ç›´æ¥ã¤ãªãŒã‚Šã®ã‚ã‚‹ç›¸æ‰‹ã®æ•°ãŒå¤šã„ã»ã©å€¤ãŒé«˜ããªã‚Šã¾ã™ã€‚</p>
            </div>
            <div class="analysis-grid">
                <div class="penguin-rank">
                    <h3>ğŸ¥‡ æ¬¡æ•°ä¸­å¿ƒæ€§ãƒ©ãƒ³ã‚­ãƒ³ã‚° TOP 10</h3>
                    <div id="degree-centrality-ranking"></div>
                </div>
                <div class="penguin-rank">
                    <h3>ğŸ“ˆ æ¬¡æ•°ä¸­å¿ƒæ€§çµ±è¨ˆ</h3>
                    <div id="degree-centrality-stats"></div>
                </div>
            </div>
        </div>
        
        <div class="analysis-section">
            <h2>ğŸŒ‰ åª’ä»‹ä¸­å¿ƒæ€§åˆ†æ</h2>
            <div class="analysis-description">
                <h3>åª’ä»‹ä¸­å¿ƒæ€§ã¨ã¯ï¼Ÿ</h3>
                <p>ä»–ã®ãƒšãƒ³ã‚®ãƒ³åŒå£«ã‚’ã¤ãªãã€Œæ©‹æ¸¡ã—ã€ã®å½¹å‰²ã‚’æœãŸã™åº¦åˆã„ã‚’è¡¨ã™æŒ‡æ¨™ã§ã™ã€‚å€¤ãŒé«˜ã„ã»ã©ã€ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£å†…ã§ã®ä»²ä»‹å½¹ã¨ã—ã¦é‡è¦ãªä½ç½®ã«ã„ã¾ã™ã€‚</p>
            </div>
            <div class="analysis-grid">
                <div class="penguin-rank">
                    <h3>ğŸ¥‡ åª’ä»‹ä¸­å¿ƒæ€§ãƒ©ãƒ³ã‚­ãƒ³ã‚° TOP 10</h3>
                    <div id="betweenness-centrality-ranking"></div>
                </div>
                <div class="penguin-rank">
                    <h3>ğŸ“ˆ åª’ä»‹ä¸­å¿ƒæ€§çµ±è¨ˆ</h3>
                    <div id="betweenness-centrality-stats"></div>
                </div>
            </div>
        </div>
        
        <div class="analysis-section">
            <h2>ğŸ¯ è¿‘æ¥ä¸­å¿ƒæ€§åˆ†æ</h2>
            <div class="analysis-description">
                <h3>è¿‘æ¥ä¸­å¿ƒæ€§ã¨ã¯ï¼Ÿ</h3>
                <p>ä»–ã®å…¨ã¦ã®ãƒšãƒ³ã‚®ãƒ³ã«å¯¾ã—ã¦ã€ã©ã‚Œã ã‘è¿‘ã„è·é›¢ï¼ˆé–¢ä¿‚ã®æ®µæ•°ï¼‰ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‹ã‚’è¡¨ã™æŒ‡æ¨™ã§ã™ã€‚å€¤ãŒé«˜ã„ã»ã©ã€ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£å…¨ä½“ã«åŠ¹ç‡çš„ã«æƒ…å ±ã‚’ä¼ãˆã‚‰ã‚Œã¾ã™ã€‚</p>
            </div>
            <div class="analysis-grid">
                <div class="penguin-rank">
                    <h3>ğŸ¥‡ è¿‘æ¥ä¸­å¿ƒæ€§ãƒ©ãƒ³ã‚­ãƒ³ã‚° TOP 10</h3>
                    <div id="closeness-centrality-ranking"></div>
                </div>
                <div class="penguin-rank">
                    <h3>ğŸ“ˆ è¿‘æ¥ä¸­å¿ƒæ€§çµ±è¨ˆ</h3>
                    <div id="closeness-centrality-stats"></div>
                </div>
            </div>
        </div>
        
        <div class="analysis-section">
            <h2>ğŸ‘¥ é–¢ä¿‚æ€§åˆ†æ</h2>
            <div class="analysis-grid">
                <div class="penguin-rank">
                    <h3>ğŸ¤ æœ€ã‚‚å‹é”ãŒå¤šã„ãƒšãƒ³ã‚®ãƒ³ TOP 10</h3>
                    <div id="most-friends-ranking"></div>
                </div>
                <div class="penguin-rank">
                    <h3>ğŸ’” æœ€ã‚‚ä¸ä»²ãŒå¤šã„ãƒšãƒ³ã‚®ãƒ³ TOP 10</h3>
                    <div id="most-conflicts-ranking"></div>
                </div>
            </div>
        </div>
        
        <div class="analysis-section">
            <h2>ğŸ“ˆ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å…¨ä½“çµ±è¨ˆ</h2>
            <div class="analysis-grid">
                <div class="penguin-rank">
                    <h3>ğŸ”¢ åŸºæœ¬çµ±è¨ˆ</h3>
                    <div id="network-stats"></div>
                </div>
                <div class="penguin-rank">
                    <h3>ğŸ”— é–¢ä¿‚æ€§çµ±è¨ˆ</h3>
                    <div id="relationship-stats"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        osql.requireLogin();
        
        let networkData = null;
        let analysisResults = null;
        
        function goBack() {
            window.location.href = 'penguin_network_simple.html';
        }
        
        async function loadAnalysis() {
            try {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('error').style.display = 'none';
                document.getElementById('analysis-results').style.display = 'none';
                
                // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                await loadNetworkData();
                
                // åˆ†æã‚’å®Ÿè¡Œ
                performAnalysis();
                
                // çµæœã‚’è¡¨ç¤º
                displayResults();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('analysis-results').style.display = 'block';
                
            } catch (error) {
                console.error('åˆ†æã‚¨ãƒ©ãƒ¼:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
            }
        }
        
        async function loadNetworkData() {
            // ãƒšãƒ³ã‚®ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const penguinSql = `
                SELECT p.id, p.name, p.gender, p.photo, p.features, p.personality, p.detail_features
                FROM penguins p
                ORDER BY p.id
            `;
            const penguins = await osql.connect(penguinSql);
            
            // é–¢ä¿‚ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const relationshipSql = `
                SELECT pr.from_id, pr.to_id, rt.type_name, pr.notes
                FROM penguin_relationships pr
                JOIN relationship_types rt ON pr.relationship_type_id = rt.id
            `;
            const relationships = await osql.connect(relationshipSql);
            
            // å®¶æ—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const familySql = `
                SELECT pf.child_id, pf.parent1_id, pf.parent2_id
                FROM penguin_family pf
            `;
            const families = await osql.connect(familySql);
            
            // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
            networkData = {
                penguins: penguins,
                relationships: relationships,
                families: families
            };
            
            console.log('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†:', networkData);
        }
        
        function performAnalysis() {
            const penguins = networkData.penguins;
            const relationships = networkData.relationships;
            const families = networkData.families;
            
            // éš£æ¥ãƒªã‚¹ãƒˆã®ä½œæˆ
            const adjacencyList = {};
            penguins.forEach(penguin => {
                adjacencyList[penguin.id] = [];
            });
            
            // é–¢ä¿‚ã‚’éš£æ¥ãƒªã‚¹ãƒˆã«è¿½åŠ ï¼ˆé‡ã¿ãªã—ï¼‰
            relationships.forEach(rel => {
                if (adjacencyList[rel.from_id] && adjacencyList[rel.to_id]) {
                    adjacencyList[rel.from_id].push({
                        id: rel.to_id,
                        type: rel.type_name,
                        weight: 1
                    });
                    adjacencyList[rel.to_id].push({
                        id: rel.from_id,
                        type: rel.type_name,
                        weight: 1
                    });
                }
            });
            
            // å®¶æ—é–¢ä¿‚ã‚’éš£æ¥ãƒªã‚¹ãƒˆã«è¿½åŠ 
            families.forEach(family => {
                if (adjacencyList[family.child_id] && adjacencyList[family.parent1_id]) {
                    adjacencyList[family.child_id].push({
                        id: family.parent1_id,
                        type: 'è¦ªå­',
                        weight: 1
                    });
                    adjacencyList[family.parent1_id].push({
                        id: family.child_id,
                        type: 'è¦ªå­',
                        weight: 1
                    });
                }
                if (family.parent2_id && adjacencyList[family.child_id] && adjacencyList[family.parent2_id]) {
                    adjacencyList[family.child_id].push({
                        id: family.parent2_id,
                        type: 'è¦ªå­',
                        weight: 1
                    });
                    adjacencyList[family.parent2_id].push({
                        id: family.child_id,
                        type: 'è¦ªå­',
                        weight: 1
                    });
                }
            });
            
            // é‡è¤‡ã‚’å‰Šé™¤
            Object.keys(adjacencyList).forEach(id => {
                const seen = new Set();
                adjacencyList[id] = adjacencyList[id].filter(neighbor => {
                    const key = `${neighbor.id}-${neighbor.type}`;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            });
            
            // åˆ†æçµæœã‚’æ ¼ç´
            analysisResults = {
                degreeCentrality: calculateDegreeCentrality(adjacencyList),
                betweennessCentrality: calculateBetweennessCentrality(adjacencyList),
                closenessCentrality: calculateClosenessCentrality(adjacencyList),
                friendsCount: calculateFriendsCount(relationships),
                conflictsCount: calculateConflictsCount(relationships),
                networkStats: calculateNetworkStats(penguins, relationships, families),
                relationshipStats: calculateRelationshipStats(relationships)
            };
            
            console.log('åˆ†æå®Œäº†:', analysisResults);
        }
        
        function calculateDegreeCentrality(adjacencyList) {
            const results = {};
            Object.keys(adjacencyList).forEach(id => {
                results[id] = adjacencyList[id].length;
            });
            return results;
        }
        
        function calculateBetweennessCentrality(adjacencyList) {
            const results = {};
            const nodes = Object.keys(adjacencyList);
            
            // å…¨ãƒãƒ¼ãƒ‰ã®åª’ä»‹ä¸­å¿ƒæ€§ã‚’0ã§åˆæœŸåŒ–
            nodes.forEach(node => {
                results[node] = 0;
            });
            
            // å„ãƒãƒ¼ãƒ‰ãƒšã‚¢ã«å¯¾ã—ã¦æœ€çŸ­çµŒè·¯ã‚’è¨ˆç®—
            nodes.forEach(source => {
                nodes.forEach(target => {
                    if (source !== target) {
                        const shortestPaths = findAllShortestPaths(adjacencyList, source, target);
                        if (shortestPaths.length > 0) {
                            // å„æœ€çŸ­çµŒè·¯ã«ã¤ã„ã¦ã€ä¸­é–“ãƒãƒ¼ãƒ‰ã«å¯¾ã—ã¦åª’ä»‹ä¸­å¿ƒæ€§ã‚’åŠ ç®—
                            shortestPaths.forEach(path => {
                                for (let i = 1; i < path.length - 1; i++) {
                                    results[path[i]] += 1.0 / shortestPaths.length;
                                }
                            });
                        }
                    }
                });
            });
            
            // æ­£è¦åŒ–: å…¨ãƒãƒ¼ãƒ‰ãƒšã‚¢æ•°ã§å‰²ã‚‹
            const totalPairs = nodes.length * (nodes.length - 1);
            nodes.forEach(node => {
                results[node] = results[node] / totalPairs;
            });
            
            return results;
        }
        
        function findAllShortestPaths(adjacencyList, source, target) {
            // BFSã‚’ä½¿ç”¨ã—ã¦æœ€çŸ­çµŒè·¯ã‚’æ¢ç´¢
            const distances = {};
            const predecessors = {};
            const queue = [source];
            
            distances[source] = 0;
            predecessors[source] = [];
            
            while (queue.length > 0) {
                const current = queue.shift();
                const currentDistance = distances[current];
                
                const neighbors = adjacencyList[current] || [];
                neighbors.forEach(neighbor => {
                    const neighborId = neighbor.id;
                    const newDistance = currentDistance + 1;
                    
                    if (!(neighborId in distances)) {
                        // åˆå›è¨ªå•
                        distances[neighborId] = newDistance;
                        predecessors[neighborId] = [current];
                        queue.push(neighborId);
                    } else if (distances[neighborId] === newDistance) {
                        // åŒã˜è·é›¢ã®åˆ¥ã®çµŒè·¯
                        predecessors[neighborId].push(current);
                    }
                });
            }
            
            // targetã«åˆ°é”ã§ããªã„å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™
            if (!(target in distances)) {
                return [];
            }
            
            // æœ€çŸ­çµŒè·¯ã‚’å†æ§‹ç¯‰
            const paths = [];
            
            function buildPaths(node, currentPath) {
                if (node === source) {
                    paths.push([source, ...currentPath.reverse()]);
                    return;
                }
                
                const preds = predecessors[node] || [];
                preds.forEach(pred => {
                    buildPaths(pred, [node, ...currentPath]);
                });
            }
            
            buildPaths(target, []);
            
            return paths;
        }
        
        function calculateClosenessCentrality(adjacencyList) {
            const results = {};
            const nodes = Object.keys(adjacencyList);
            
            nodes.forEach(node => {
                const distances = calculateShortestDistances(adjacencyList, node);
                
                // åˆ°é”å¯èƒ½ãªãƒãƒ¼ãƒ‰ã®ã¿ã‚’è€ƒæ…®
                const reachableDistances = Object.values(distances).filter(dist => dist > 0);
                
                if (reachableDistances.length > 0) {
                    const totalDistance = reachableDistances.reduce((sum, dist) => sum + dist, 0);
                    // æ­£è¦åŒ–: åˆ°é”å¯èƒ½ãªãƒãƒ¼ãƒ‰æ•° / ç·è·é›¢
                    results[node] = reachableDistances.length / totalDistance;
                } else {
                    results[node] = 0;
                }
            });
            
            return results;
        }
        
        function calculateShortestDistances(adjacencyList, source) {
            const distances = {};
            const visited = new Set();
            const queue = [{ node: source, distance: 0 }];
            
            distances[source] = 0;
            
            while (queue.length > 0) {
                queue.sort((a, b) => a.distance - b.distance);
                const { node, distance } = queue.shift();
                
                if (visited.has(node)) continue;
                visited.add(node);
                
                const neighbors = adjacencyList[node] || [];
                neighbors.forEach(neighbor => {
                    if (!visited.has(neighbor.id)) {
                        const newDistance = distance + 1;
                        if (distances[neighbor.id] === undefined || newDistance < distances[neighbor.id]) {
                            distances[neighbor.id] = newDistance;
                            queue.push({ node: neighbor.id, distance: newDistance });
                        }
                    }
                });
            }
            
            return distances;
        }
        
        function calculateFriendsCount(relationships) {
            const friendsCounts = {};
            
            relationships.forEach(rel => {
                if (rel.type_name === 'å‹é”') {
                    friendsCounts[rel.from_id] = (friendsCounts[rel.from_id] || 0) + 1;
                    friendsCounts[rel.to_id] = (friendsCounts[rel.to_id] || 0) + 1;
                }
            });
            
            return friendsCounts;
        }
        
        function calculateConflictsCount(relationships) {
            const conflictsCounts = {};
            
            relationships.forEach(rel => {
                if (rel.type_name === 'ä¸ä»²') {
                    conflictsCounts[rel.from_id] = (conflictsCounts[rel.from_id] || 0) + 1;
                    conflictsCounts[rel.to_id] = (conflictsCounts[rel.to_id] || 0) + 1;
                }
            });
            
            return conflictsCounts;
        }
        
        function calculateNetworkStats(penguins, relationships, families) {
            const totalNodes = penguins.length;
            const totalEdges = relationships.length + families.length;
            const maleCount = penguins.filter(p => p.gender === 'ã‚ªã‚¹' || p.gender === 'ç”·').length;
            const femaleCount = penguins.filter(p => p.gender === 'ãƒ¡ã‚¹' || p.gender === 'å¥³').length;
            
            return {
                totalNodes,
                totalEdges,
                maleCount,
                femaleCount,
                density: (totalEdges * 2) / (totalNodes * (totalNodes - 1))
            };
        }
        
        function calculateRelationshipStats(relationships) {
            const typeCounts = {};
            
            relationships.forEach(rel => {
                typeCounts[rel.type_name] = (typeCounts[rel.type_name] || 0) + 1;
            });
            
            return typeCounts;
        }
        
        function displayResults() {
            const penguins = networkData.penguins;
            const penguinMap = {};
            penguins.forEach(p => {
                penguinMap[p.id] = p;
            });
            
            // æ¬¡æ•°ä¸­å¿ƒæ€§ãƒ©ãƒ³ã‚­ãƒ³ã‚°
            displayRanking('degree-centrality-ranking', analysisResults.degreeCentrality, penguinMap, 'æ¥ç¶šæ•°');
            displayCentralityStats('degree-centrality-stats', analysisResults.degreeCentrality, 'æ¬¡æ•°ä¸­å¿ƒæ€§');
            
            // åª’ä»‹ä¸­å¿ƒæ€§ãƒ©ãƒ³ã‚­ãƒ³ã‚°
            displayRanking('betweenness-centrality-ranking', analysisResults.betweennessCentrality, penguinMap, 'åª’ä»‹åº¦');
            displayCentralityStats('betweenness-centrality-stats', analysisResults.betweennessCentrality, 'åª’ä»‹ä¸­å¿ƒæ€§');
            
            // è¿‘æ¥ä¸­å¿ƒæ€§ãƒ©ãƒ³ã‚­ãƒ³ã‚°
            displayRanking('closeness-centrality-ranking', analysisResults.closenessCentrality, penguinMap, 'è¿‘æ¥åº¦');
            displayCentralityStats('closeness-centrality-stats', analysisResults.closenessCentrality, 'è¿‘æ¥ä¸­å¿ƒæ€§');
            
            // å‹é”ãƒ©ãƒ³ã‚­ãƒ³ã‚°
            displayRanking('most-friends-ranking', analysisResults.friendsCount, penguinMap, 'å‹é”æ•°');
            
            // ä¸ä»²ãƒ©ãƒ³ã‚­ãƒ³ã‚°
            displayRanking('most-conflicts-ranking', analysisResults.conflictsCount, penguinMap, 'ä¸ä»²æ•°');
            
            // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çµ±è¨ˆ
            displayNetworkStats();
            
            // é–¢ä¿‚æ€§çµ±è¨ˆ
            displayRelationshipStats();
        }
        
        function displayRanking(elementId, scores, penguinMap, unit) {
            const element = document.getElementById(elementId);
            const sortedScores = Object.entries(scores)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);
            
            if (sortedScores.length === 0) {
                element.innerHTML = '<p>ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            let html = '';
            sortedScores.forEach(([id, score], index) => {
                const penguin = penguinMap[id];
                if (penguin) {
                    const genderClass = (penguin.gender === 'ã‚ªã‚¹' || penguin.gender === 'ç”·') ? 'gender-male' : 'gender-female';
                    const scoreValue = unit === 'æ¥ç¶šæ•°' ? score : score.toFixed(3);
                    html += `
                        <div class="rank-item" onclick="showPenguinDetails('${id}', '${penguin.name}')">
                            <span class="rank-number">${index + 1}</span>
                            <span class="penguin-name ${genderClass}">${penguin.name}</span>
                            <span class="score">${unit}: ${scoreValue}</span>
                        </div>
                    `;
                }
            });
            
            element.innerHTML = html;
        }
        
        function displayCentralityStats(elementId, scores, metricName) {
            const element = document.getElementById(elementId);
            const values = Object.values(scores);
            
            if (values.length === 0) {
                element.innerHTML = '<p>ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            const max = Math.max(...values);
            const min = Math.min(...values);
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
            
            element.innerHTML = `
                <div class="metric-value">æœ€å¤§å€¤: ${max.toFixed(2)}</div>
                <div class="metric-value">æœ€å°å€¤: ${min.toFixed(2)}</div>
                <div class="metric-value">å¹³å‡å€¤: ${avg.toFixed(2)}</div>
                <div class="metric-value">æ¨™æº–åå·®: ${calculateStandardDeviation(values).toFixed(2)}</div>
            `;
        }
        
        function calculateStandardDeviation(values) {
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
            const squaredDiffs = values.map(val => Math.pow(val - avg, 2));
            const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
            return Math.sqrt(avgSquaredDiff);
        }
        
        function displayNetworkStats() {
            const stats = analysisResults.networkStats;
            const element = document.getElementById('network-stats');
            
            element.innerHTML = `
                <div class="metric-value">ç·ãƒšãƒ³ã‚®ãƒ³æ•°: ${stats.totalNodes}</div>
                <div class="metric-value">ç·é–¢ä¿‚æ•°: ${stats.totalEdges}</div>
                <div class="metric-value">ã‚ªã‚¹: ${stats.maleCount}</div>
                <div class="metric-value">ãƒ¡ã‚¹: ${stats.femaleCount}</div>
                <div class="metric-value">å¯†åº¦: ${(stats.density * 100).toFixed(2)}%</div>
            `;
        }
        
        function displayRelationshipStats() {
            const stats = analysisResults.relationshipStats;
            const element = document.getElementById('relationship-stats');
            
            let html = '';
            Object.entries(stats).forEach(([type, count]) => {
                html += `<div class="metric-value">${type}: ${count}</div>`;
            });
            
            element.innerHTML = html;
        }
        
        function showPenguinDetails(penguinId, penguinName) {
            // é¸æŠã•ã‚ŒãŸãƒšãƒ³ã‚®ãƒ³ã®è©³ç´°ãªé–¢ä¿‚ã‚’è¡¨ç¤º
            if (!networkData) {
                alert('ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const relationships = networkData.relationships;
            const families = networkData.families;
            const penguin = networkData.penguins.find(p => p.id == penguinId);
            
            if (!penguin) {
                alert('ãƒšãƒ³ã‚®ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // é–¢ä¿‚ã®è©³ç´°ã‚’åé›†
            const relationshipDetails = [];
            
            // é€šå¸¸ã®é–¢ä¿‚
            relationships.forEach(rel => {
                if (rel.from_id == penguinId) {
                    const partner = networkData.penguins.find(p => p.id == rel.to_id);
                    if (partner) {
                        relationshipDetails.push(`${rel.type_name}: ${partner.name}`);
                    }
                }
                if (rel.to_id == penguinId) {
                    const partner = networkData.penguins.find(p => p.id == rel.from_id);
                    if (partner) {
                        relationshipDetails.push(`${rel.type_name}: ${partner.name}`);
                    }
                }
            });
            
            // å®¶æ—é–¢ä¿‚
            families.forEach(family => {
                if (family.child_id == penguinId) {
                    const parent1 = networkData.penguins.find(p => p.id == family.parent1_id);
                    if (parent1) {
                        relationshipDetails.push(`è¦ªå­é–¢ä¿‚: ${parent1.name}ï¼ˆè¦ªï¼‰`);
                    }
                    if (family.parent2_id) {
                        const parent2 = networkData.penguins.find(p => p.id == family.parent2_id);
                        if (parent2) {
                            relationshipDetails.push(`è¦ªå­é–¢ä¿‚: ${parent2.name}ï¼ˆè¦ªï¼‰`);
                        }
                    }
                }
                if (family.parent1_id == penguinId || family.parent2_id == penguinId) {
                    const child = networkData.penguins.find(p => p.id == family.child_id);
                    if (child) {
                        relationshipDetails.push(`è¦ªå­é–¢ä¿‚: ${child.name}ï¼ˆå­ï¼‰`);
                    }
                }
            });
            
            // é‡è¤‡ã‚’é™¤å»
            const uniqueRelationships = [...new Set(relationshipDetails)];
            
            const message = `${penguinName}ã®é–¢ä¿‚è©³ç´°ï¼ˆåˆè¨ˆ: ${uniqueRelationships.length}ï¼‰:\n\n${uniqueRelationships.join('\n')}`;
            alert(message);
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«è‡ªå‹•å®Ÿè¡Œ
        window.onload = function() {
            // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§è‡ªå‹•å®Ÿè¡Œãƒ•ãƒ©ã‚°ãŒã‚ã‚Œã°å®Ÿè¡Œ
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('auto') === 'true') {
                loadAnalysis();
            }
        };
    </script>
</body>
</html>